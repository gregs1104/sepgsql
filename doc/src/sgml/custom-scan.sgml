<!-- doc/src/sgml/custom-scan.sgml -->

<chapter id="custom-scan">
 <title>Writing A Custom Scan Provider</title>

 <indexterm zone="custom-scan">
  <primary>custom scan</primary>
  <secondary>handler for</secondary>
 </indexterm>
 <para>
  The custom-scan API enables an extension to provide alternative ways to scan
  or join relations leveraging the cost based optimizer. The API consists of a
  set of callbacks, with a unique names, to be invoked during query planning 
  and execution. A custom-scan provider should implement these callback 
  functions according to the expectation of the API.
 </para>
 <para>
  Overall, there are four major tasks that a custom-scan provider should 
  implement. The first task is the registration of custom-scan provider itself.
  Usually, this needs to be done once at the <literal>_PG_init()</literal> 
  entrypoint when the module is loading. The remaing three tasks are all done
  when a query is planning and executing. The second task is the submission of
  candidate paths to either scan or join relations with an adequate cost for
  the core planner. Then, the planner will choose the cheapest path from all of
  the candidates. If the custom path survived, the planner starts the third 
  task; construction of a <literal>CustomScan</literal> plan node, located
  within the query plan tree instead of the built-in plan node. The last task
  is the execution of its implementation in answer to invocations by the core
  executor.
 </para>
 <para>
  Some of contrib modules utilize the custom-scan API. They may provide a good
  example for new development.
  <variablelist>
   <varlistentry>
    <term><xref linkend="ctidscan"></term>
    <listitem>
     <para>
      This custom scan in this module enables a scan to skip earlier pages or
      terminate prior to end of the relation, if the inequality operator on the
      <literal>ctid</literal> system column can narrow down the scope to be
      scanned, instead of a sequential scan which reads a relation from the
      head to the end.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><xref linkend="postgres-fdw"></term>
    <listitem>
     <para>
      This custom scan in this module replaces a local join of foreign tables
      managed by <literal>postgres_fdw</literal> with a scan that fetches
      remotely joined relations. It demostrates the way to implement a custom
      scan node that performs join nodes.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </para>
 <para>
  Currently, only scan and join are fully supported with integrated cost
  based query optimization using the custom scan API. You might be able to
  implement other stuff, like sort or aggregation, with manipulation of the
  planned tree, however, the extension has to be responsible to handle this
  replacement correctly. There is no support in the core.
 </para>

 <sect1 id="custom-scan-spec">
  <title>Custom Scan API Functions and Callbacks</title>
  <sect2 id="custom-scan-register">
   <title>Registration of custom scan provider</title>
   <para>
    The first task for a custom scan provider is the registration of a set of
    callbacks with a unique names. Usually, this is done once upon module
    loading in the <literal>_PG_init()</literal> entrypoint.
<programlisting>
void
register_custom_provider(const CustomProvider *provider);
</programlisting>
    Its argument, <literal>CustomProvider</literal> structure, contains
    a name and a set of callback function pointers but some of them are
    optional.
    Once registered, it is copied on the internal table, so the caller
    does not need to keep this structure any more.
   </para>
  </sect2>

  <sect2 id="custom-scan-path">
   <title>Submission of custom paths</title>
   <para>
    The query planner finds the best way to scan or join relations from various
    potential paths using a combination of scan algorithms and target 
    relations. Prior to this selection, we list all of the potential paths
    towards a target relation (if it is a base relation) or a pair of relations
    (if it is a join). The <literal>add_scan_path_hook</> and
    <literal>add_join_path_hook</> allow extensions to add alternative scan
    paths in addition to built-in paths.
    If custom-scan provider can submit a potential scan path towards the
    supplied relation, it shall construct a <literal>CustomPath</> object
    with appropriate parameters.
<programlisting>
typedef struct CustomPath
{
    Path        path;
    const char *custom_name;        /* name of custom scan provider */
    int         custom_flags;       /* CUSTOM__* flags in nodeCustom.h */
    List       *custom_private;     /* can be used for private data */
} CustomPath;
</programlisting>
    Its <literal>path</> is a common field for all the path nodes to store
    a cost estimation. In addition, <literal>custom_name</> is the name of
    the registered custom scan provider, <literal>custom_flags</> is a set of
    flags below, and <literal>custom_private</> can be used to store private
    data of the custom scan provider.
   </para>
   <para>
    <variablelist>
     <varlistentry>
      <term><literal>CUSTOM__SUPPORT_MARK_RESTORE</></term>
      <listitem>
       <para>
        It informs the query planner this custom scan node supports
        <literal>ExecMarkPosCustomScan</> and
        <literal>ExecRestorePosCustomScan</> methods.
        Also, the custom scan provider has to be responsible to mark and
        restore a particular position.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>CUSTOM__SUPPORT_BACKWARD_SCAN</></term>
      <listitem>
       <para>
        It informs the query planner this custom scan node supports
        backward scans.
        Also, custom scan provider has to be responsible to scan with
        backward direction.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2 id="custom-scan-plan">
   <title>Construction of custom plan node</title>
   <para>
    Once <literal>CustomPath</literal> was choosen by the query planner,
    it calls back to its associated to the custom scan provider to complete 
    setting up the <literal>CustomScan</literal> plan node according to the
    path information.
<programlisting>
void
InitCustomScanPlan(PlannerInfo *root,
                   CustomScan *cscan_plan,
                   CustomPath *cscan_path,
                   List *tlist,
                   List *scan_clauses);
</programlisting>
    The query planner does basic initialization on the <literal>cscan_plan</>
    being allocated, then the custom scan provider can apply final 
    initialization. <literal>cscan_path</> is the path node that was 
    constructed on the previous stage then was choosen.
    <literal>tlist</> is a list of <literal>TargetEntry</> to be assigned
    on the <literal>Plan</> portion in the <literal>cscan_plan</>.
    Also, <literal>scan_clauses</> is a list of <literal>RestrictInfo</> to
    be checked during a relation scan. Its expression portion will also be
    assigned on the <literal>Plan</> portion, but can be eliminated from
    this list if custom scan provider can handle these checks by itself.
   </para>
   <para>
    It often needs to adjust <literal>varno</> of <literal>Var</> node that
    references a particular scan node, after construction of the plan node.
    For example, Var node in the target list of the join node originally
    references a particular relation underlying a join, however, it has to
    be adjusted to either inner or outer reference.
<programlisting>
void
SetPlanRefCustomScan(PlannerInfo *root,
                     CustomScan *cscan_plan,
                     int rtoffset);
</programlisting>
    This callback is optional if the custom scan node is a vanilla relation
    scan because there is nothing special to do. Elsewhere, it needs to
    be handled by the custom scan provider in case when a custom scan replaced
    a join with two or more relations for example.
   </para>
  </sect2>

  <sect2 id="custom-scan-exec">
   <title>Execution of custom scan node</title>
   <para>
    The query executor also launches the associated callbacks to begin, execute
    and end the custom scan according to the executor's manner.
   </para>
   <para>
<programlisting>
void
BeginCustomScan(CustomScanState *csstate, int eflags);
</programlisting>
    It begins execution of the custom scan on starting up executor.
    It allows the custom scan provider to do any initialization job around this
    plan, however, it is not a good idea to launch the actual scanning jobs.
    (It shall be done on the first invocation of <literal>ExecCustomScan</>
    instead.)
    The <literal>custom_state</> field of <literal>CustomScanState</> is
    intended to save the private state being managed by the custom scan
    provider. Also, <literal>eflags</> has flag bits of the executor's
    operating mode for this plan node. Note that the custom scan provider
    should not perform anything visible externally if 
    <literal>EXEC_FLAG_EXPLAIN_ONLY</> would be given,
   </para>

   <para>
<programlisting>
TupleTableSlot *
ExecCustomScan(CustomScanState *csstate);
</programlisting>
    It fetches one tuple from the underlying relation or relations, if joining,
    according to the custom logic. Unlike <literal>IterateForeignScan</>
    method in foreign table, it is also responsible to check whether the next
    tuple matches the qualifier of this scan, or not.
    The usual way to implement this method is the callback performs just an
    entrypoint of <literal>ExecQual</> with its own access method.
   </para>

   <para>
<programlisting>
Node *
MultiExecCustomScan(CustomScanState *csstate);
</programlisting>
    It fetches multiple tuples from the underlying relation or relations, if
    joining, according to the custom logic. Pay attention the data format (and
    the way to return also) since it depends on the type of upper node.
   </para>

   <para>
<programlisting>
void
EndCustomScan(CustomScanState *csstate);
</programlisting>
    It ends the scan and releases resources privately allocated.
    It is usually not important to release memory in per-execution memory
    context. So, all this callback should be responsible is its own
    resources regardless from the framework.
   </para>
  </sect2>

  <sect2 id="custom-scan-misc">
   <title>Miscellaneous jobs</title>
   <para>
<programlisting>
void
ReScanCustomScan(CustomScanState *csstate);
</programlisting>
    It restarts the current scan from the beginning.
    Note that parameters of the scan depends on may change values,
    so rewinded scan does not need to return exactly identical tuples.
   </para>
   <para>
<programlisting>
void
MarkPosCustomScan(CustomScanState *csstate);
</programlisting>
    It saves the current position of the custom scan on somewhere private
    state.
    Note that it is optional to implement, only when
    <literal>CUSTOM__SUPPORT_MARK_RESTORE</> is set.
   </para>
   <para>
<programlisting>
void
RestorePosCustom(CustomScanState *csstate);
</programlisting>
    It rewinds the current position of the custom scan to the position
    where <literal>MarkPosCustomScan</> was saved before.
    Note that it is optional to implement, only when
    <literal>CUSTOM__SUPPORT_MARK_RESTORE</> is set.
   </para>
   <para>
<programlisting>
void
ExplainCustomScan(CustomScanState *csstate,
                  ExplainState *es);
</programlisting>
    It prints additional <command>EXPLAIN</> output for a custom scan plan.
    This callback is expected to call <literal>ExplainPropertyText</> to
    make additional field of <command>EXPLAIN</> output.
    The flag fields in <literal>ExplainState</> indicates what shall be
    printed, and the state of the <literal>CustomScanState</> will provide
    run-time statistics in the <command>EXPLAIN ANALYZE</> case.
   </para>
  </sect2>
 </sect1>
</chapter>
